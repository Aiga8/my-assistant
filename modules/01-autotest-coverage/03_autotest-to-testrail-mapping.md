# Этап 3 — Маппинг автотестов на TestRail

Промт и технические детали. Общий процесс: [README.md](README.md).

---

## Назначение

Сопоставить подготовленные описания автотестов (Этап 1) с выгруженными кейсами TestRail (Этап 2), определить статус покрытия (Covered / Partial / Not found) и зафиксировать лучшего кандидата и обоснование.

---

## Входные данные

- **Описания автотестов:** Markdown-файл из Этапа 1  
  `results/01-autotest-coverage/<номер_задачи>_<область>.md`  
  либо сабсет: `results/01-autotest-coverage/all-tests-<subset>-only.md`.
- **Выгрузка кейсов TestRail:** JSON из Этапа 2  
  `results/01-autotest-coverage/testrail-section-<SECTION_ID>-subtree-cases.json`

---

## Фильтрация в сабсеты (опционально)

Чтобы маппить только тесты, относящиеся к конкретной секции/виджету:

- **По пути:** скрипты `scripts/filter_all_tests_by_path.mjs`, `scripts/group_all_tests_by_path.mjs`.
- **По ключевым словам:** `scripts/filter_all_tests_by_keyword.mjs` (с возможностью исключений).

Сабсет сохраняется, например, в `results/01-autotest-coverage/all-tests-<subset>-only.md` и передаётся в скрипт маппинга как `--input`.

---

## Инструмент маппинга

Скрипт (в корне репозитория):

`scripts/geotarget_map_to_testrail.mjs`

Универсальный: принимает любой `--input` (описания) и `--cases` (JSON выгрузки).

Пример:

```bash
node scripts/geotarget_map_to_testrail.mjs ^
  --input results/01-autotest-coverage/all-tests-<subset>-only.md ^
  --cases results/01-autotest-coverage/testrail-section-<SECTION_ID>-subtree-cases.json ^
  --out-base results/01-autotest-coverage/<subset>-section<SECTION_ID>-testrail-mapping-<dd_mm_yy>
```

Скрипт сохраняет два файла:
- `<out-base>.md` — читаемый отчёт;
- `<out-base>.json` — структурированный источник истины для сборки рабочего файла.

---

## Правила сопоставления (обязательно для LLM/ручной проверки)

### Поиск кандидатов

- Поиск выполняется **строго по выгруженным кейсам** (по файлу из Этапа 2). MCP-поиск по TestRail не используется.
- Учитываются: название кейса, шаги, ожидаемый результат.
- **Игнорировать** при расчёте релевантности слова визуальной регрессии:  
  `screenshot`, `snapshot`, `baseline`, `golden`, `visual`, `pixel`, `скриншот`, `эталон`.

### Релевантность (ориентир)

- ≥60% ключевых слов / совпадение сценария → сильный кандидат.
- 30–60% → похожий кандидат (учитывать в Partial).

### Принцип функционального ядра

- Перед оценкой выделить минимальное «ядро сценария» — ключевые действия и проверки, без которых сценарий теряет смысл.
- Если кейс покрывает ядро, но не все детали → минимум **Partial**.
- **Covered** — только при сильном совпадении или явном соответствии (UI-флоу автоматизирован, ключевые проверки есть).

---

## Статусы покрытия

| Статус | Значение |
|--------|----------|
| **Covered** | UI-флоу автоматизирован, ключевые проверки выполнены (бэкенд может быть замокан). |
| **Partial** | Покрыта основная логика, но отсутствуют важные проверки (например: D&D не проверен, не проверено disabled для VIEWER, не проверена отправка настроек). |
| **Not found** | Релевантных кейсов в выгрузке нет. |

**Важно (Automation/Covered vs Partial):** автотест считается покрывающим кейс, если проверяет ключевой UI-флоу и важные UI-состояния, даже при замоканном бэкенде. Partial ставится, когда в автотесте отсутствует важная часть UI-проверки.

---

## Выходные файлы этапа

- По каждому запуску маппинга (сабсету):  
  `<out-base>.md`, `<out-base>.json` в `results/01-autotest-coverage/`.
- Агрегированный рабочий файл (один на все тесты):  
  `results/01-autotest-coverage/all-tests-testrail-mapping.md`

Пересборка рабочего файла из всех `*-testrail-mapping*.json`:

```bash
node scripts/rebuild_all_tests_working_file.mjs
```

Скрипт: сортировка по исходному номеру теста (sourceId), удаление дублей (одна запись на тест), точечный фикс — новый маппинг для теста перезаписывает старый.

---

## Формат отчёта (MD)

Для каждого теста в отчёте:

- `### <sourceId>. <Название сценария>`
- **Автотест:** путь, название теста.
- **Найдено в TestRail:** лучший кандидат + альтернативы (или полный список, если автотест агрегирует несколько кейсов).
- **Обоснование:** кратко, почему выбран этот кандидат/статус.
- **Статус:** `Covered | Partial | Not found`.

---

## Фиксация связи в TestRail (практика разметки)

Рекомендуемый формат в поле **Refs** или в комментарии к кейсу:

`playwright/tests/<путь>/<файл>.spec.ts::test name`

Пример:

`playwright/tests/bha-import/bha-import.spec.ts::Complete BHA import functionality test`

Для **Partial:** в коде автотеста лучше не ставить прямую ссылку на TR-кейс; фиксировать Partial в TestRail (комментарий/статус).

---

## Точечная правка (point fix)

Когда нужно обновить маппинг только для одного теста (другая секция, другой кейс, исправление статуса):

1. При необходимости экспортировать нужную секцию заново (Этап 2).
2. Сформировать сабсет только с этим тестом (или один тест в файле).
3. Запустить маппинг; при пересборке рабочего файла через `rebuild_all_tests_working_file.mjs` новая запись перезапишет старую по sourceId.

---

## Prompt (шаблон для Cursor/LLM)

**Контекст:**
- Project: `project_id=5` (или уточнить).
- Входной файл описаний: `results/01-autotest-coverage/<файл>.md` или сабсет.
- Рабочий файл результата: `results/01-autotest-coverage/all-tests-testrail-mapping.md`.
- Поиск кейсов: **только** в выгруженном JSON для нужного `section_id` (файл из Этапа 2).

**Инструкция:**

1. Экспортировать кейсы TestRail для нужного `section_id` (Этап 2), если выгрузки ещё нет.
2. При необходимости подготовить сабсет тестов под эту секцию (по path/ключевым словам), сохранить в `results/01-autotest-coverage/`.
3. Запустить маппинг: `scripts/geotarget_map_to_testrail.mjs` с `--input`, `--cases`, `--out-base` в `results/01-autotest-coverage/`.
4. Обновить рабочий файл: запустить `scripts/rebuild_all_tests_working_file.mjs`. Сохранить сортировку по исходному номеру теста, отсутствие дублей; точечные фиксы должны перезаписывать старые результаты.

**Правила сопоставления:** искать кандидатов только по выгруженным кейсам; игнорировать визуальную регрессию при скоринге; использовать принцип функционального ядра (ядро покрыто → минимум Partial; Covered только при сильном совпадении).
